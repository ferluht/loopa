\hypertarget{_interp_delay2_8hpp_source}{}\doxysection{Interp\+Delay2.\+hpp}
\label{_interp_delay2_8hpp_source}\index{effects\_audio/Plateau/InterpDelay2.hpp@{effects\_audio/Plateau/InterpDelay2.hpp}}
\mbox{\hyperlink{_interp_delay2_8hpp}{Go to the documentation of this file.}}
\begin{DoxyCode}{0}
\DoxyCodeLine{1 }
\DoxyCodeLine{7 \textcolor{preprocessor}{\#ifndef IND2\_HPP}}
\DoxyCodeLine{8 \textcolor{preprocessor}{\#define IND2\_HPP}}
\DoxyCodeLine{9 }
\DoxyCodeLine{10 \textcolor{preprocessor}{\#include <vector>}}
\DoxyCodeLine{11 }
\DoxyCodeLine{12 \textcolor{preprocessor}{ \#include <cstdint>}}
\DoxyCodeLine{13 \textcolor{comment}{// \#include "{}../Utilities.hpp"{}}}
\DoxyCodeLine{14 }
\DoxyCodeLine{16 \textcolor{keyword}{inline} \textcolor{keywordtype}{float} linterp(\textcolor{keywordtype}{float} a, \textcolor{keywordtype}{float} b, \textcolor{keywordtype}{float} f) \{}
\DoxyCodeLine{17     \textcolor{keywordflow}{return} a + f * (b -\/ a);}
\DoxyCodeLine{18 \}}
\DoxyCodeLine{19 }
\DoxyCodeLine{21 \textcolor{keyword}{template}<\textcolor{keyword}{typename} T = \textcolor{keywordtype}{float}>}
\DoxyCodeLine{22 \textcolor{keyword}{class }InterpDelay2 \{}
\DoxyCodeLine{23 \textcolor{keyword}{public}:}
\DoxyCodeLine{24     T input = T(0);}
\DoxyCodeLine{25     T output = T(0);}
\DoxyCodeLine{26 }
\DoxyCodeLine{27     InterpDelay2(uint64\_t maxLength = 512, uint64\_t initDelayTime = 0) \{}
\DoxyCodeLine{28         l = maxLength;}
\DoxyCodeLine{29         buffer = std::vector<T>(l, T(0));}
\DoxyCodeLine{30         setDelayTime(initDelayTime);}
\DoxyCodeLine{31     \}}
\DoxyCodeLine{32 }
\DoxyCodeLine{33     \textcolor{keywordtype}{void} process() \{}
\DoxyCodeLine{34         buffer[w] = input;}
\DoxyCodeLine{35         int64\_t r = w -\/ t;}
\DoxyCodeLine{36         \textcolor{keywordflow}{if} (r < 0) \{}
\DoxyCodeLine{37             r += l;}
\DoxyCodeLine{38         \}}
\DoxyCodeLine{39 }
\DoxyCodeLine{40         ++w;}
\DoxyCodeLine{41         \textcolor{keywordflow}{if} (w == l) \{}
\DoxyCodeLine{42             w = 0;}
\DoxyCodeLine{43         \}}
\DoxyCodeLine{44 }
\DoxyCodeLine{45         int64\_t upperR = r -\/ 1;}
\DoxyCodeLine{46         \textcolor{keywordflow}{if} (upperR < 0) \{}
\DoxyCodeLine{47             upperR += l;}
\DoxyCodeLine{48         \}}
\DoxyCodeLine{49 }
\DoxyCodeLine{50         output = linterp(buffer[r], buffer[upperR], f);}
\DoxyCodeLine{51     \}}
\DoxyCodeLine{52 }
\DoxyCodeLine{53     \textcolor{keywordtype}{void} blockProcess(\textcolor{keyword}{const} T* inputBuffer, T* outputBuffer, \textcolor{keyword}{const} uint64\_t blockSize) \{}
\DoxyCodeLine{54         \textcolor{keywordflow}{for} (uint64\_t i = 0; i < blockSize; ++i) \{}
\DoxyCodeLine{55             buffer[w] = inputBuffer[i];}
\DoxyCodeLine{56             int64\_t r = w -\/ t;}
\DoxyCodeLine{57             \textcolor{keywordflow}{if} (r < 0) \{}
\DoxyCodeLine{58                 r += l;}
\DoxyCodeLine{59             \}}
\DoxyCodeLine{60 }
\DoxyCodeLine{61             ++w;}
\DoxyCodeLine{62             \textcolor{keywordflow}{if} (w == l) \{}
\DoxyCodeLine{63                 w = 0;}
\DoxyCodeLine{64             \}}
\DoxyCodeLine{65 }
\DoxyCodeLine{66             int64\_t upperR = r -\/ 1;}
\DoxyCodeLine{67             \textcolor{keywordflow}{if} (upperR < 0) \{}
\DoxyCodeLine{68                 upperR += l;}
\DoxyCodeLine{69             \}}
\DoxyCodeLine{70 }
\DoxyCodeLine{71             outputBuffer[i] = linterp(buffer[r], buffer[upperR], f);}
\DoxyCodeLine{72         \}}
\DoxyCodeLine{73     \}}
\DoxyCodeLine{74 }
\DoxyCodeLine{75     T tap(int64\_t i)\textcolor{keyword}{ const }\{}
\DoxyCodeLine{76         int64\_t j = w -\/ i;}
\DoxyCodeLine{77         \textcolor{keywordflow}{if} (j < 0) \{}
\DoxyCodeLine{78             j += l;}
\DoxyCodeLine{79         \}}
\DoxyCodeLine{80         \textcolor{keywordflow}{return} buffer[j];}
\DoxyCodeLine{81     \}}
\DoxyCodeLine{82 }
\DoxyCodeLine{83     \textcolor{keywordtype}{void} setDelayTime(T newDelayTime) \{}
\DoxyCodeLine{84         \textcolor{keywordflow}{if} (newDelayTime >= l) \{}
\DoxyCodeLine{85             newDelayTime = l -\/ 1;}
\DoxyCodeLine{86         \}}
\DoxyCodeLine{87         \textcolor{keywordflow}{if} (newDelayTime < 0) \{}
\DoxyCodeLine{88             newDelayTime = 0;}
\DoxyCodeLine{89         \}}
\DoxyCodeLine{90         t = \textcolor{keyword}{static\_cast<}int64\_t\textcolor{keyword}{>}(newDelayTime);}
\DoxyCodeLine{91         f = newDelayTime -\/ \textcolor{keyword}{static\_cast<}T\textcolor{keyword}{>}(t);}
\DoxyCodeLine{92     \}}
\DoxyCodeLine{93 }
\DoxyCodeLine{94     \textcolor{keywordtype}{void} clear() \{}
\DoxyCodeLine{95         std::fill(buffer.begin(), buffer.end(), T(0));}
\DoxyCodeLine{96         input = T(0);}
\DoxyCodeLine{97         output = T(0);}
\DoxyCodeLine{98     \}}
\DoxyCodeLine{99 }
\DoxyCodeLine{100 \textcolor{keyword}{private}:}
\DoxyCodeLine{101     std::vector<T> buffer;}
\DoxyCodeLine{102     int64\_t w = 0;}
\DoxyCodeLine{103     int64\_t t = 0;}
\DoxyCodeLine{104     T f = T(0);}
\DoxyCodeLine{105     int64\_t l = 512;}
\DoxyCodeLine{106 \};}
\DoxyCodeLine{107 }
\DoxyCodeLine{108 \textcolor{preprocessor}{\#endif}}

\end{DoxyCode}
