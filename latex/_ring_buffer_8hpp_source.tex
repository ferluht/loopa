\hypertarget{_ring_buffer_8hpp_source}{}\doxysection{Ring\+Buffer.\+hpp}
\label{_ring_buffer_8hpp_source}\index{common/RingBuffer.hpp@{common/RingBuffer.hpp}}

\begin{DoxyCode}{0}
\DoxyCodeLine{1 \textcolor{preprocessor}{\#pragma once}}
\DoxyCodeLine{2 \textcolor{preprocessor}{\#include <atomic>}}
\DoxyCodeLine{3 \textcolor{preprocessor}{\#include <cstring>}}
\DoxyCodeLine{4 }
\DoxyCodeLine{8 \textcolor{keyword}{template} <\textcolor{keyword}{typename} T, \textcolor{keywordtype}{size\_t} S>}
\DoxyCodeLine{9 \textcolor{keyword}{struct }DoubleRingBuffer \{}
\DoxyCodeLine{10     std::atomic<size\_t> start\{0\};}
\DoxyCodeLine{11     std::atomic<size\_t> end\{0\};}
\DoxyCodeLine{12     T data[2 * S];}
\DoxyCodeLine{13 }
\DoxyCodeLine{14     \textcolor{keywordtype}{void} push(T t) \{}
\DoxyCodeLine{15         \textcolor{keywordtype}{size\_t} i = end \% S;}
\DoxyCodeLine{16         data[i] = t;}
\DoxyCodeLine{17         data[i + S] = t;}
\DoxyCodeLine{18         end++;}
\DoxyCodeLine{19     \}}
\DoxyCodeLine{20     T shift() \{}
\DoxyCodeLine{21         \textcolor{keywordtype}{size\_t} i = start \% S;}
\DoxyCodeLine{22         T t = data[i];}
\DoxyCodeLine{23         start++;}
\DoxyCodeLine{24         \textcolor{keywordflow}{return} t;}
\DoxyCodeLine{25     \}}
\DoxyCodeLine{26     \textcolor{keywordtype}{void} clear() \{}
\DoxyCodeLine{27         start = end.load();}
\DoxyCodeLine{28     \}}
\DoxyCodeLine{29     \textcolor{keywordtype}{bool} empty()\textcolor{keyword}{ const }\{}
\DoxyCodeLine{30         \textcolor{keywordflow}{return} start >= end;}
\DoxyCodeLine{31     \}}
\DoxyCodeLine{32     \textcolor{keywordtype}{bool} full()\textcolor{keyword}{ const }\{}
\DoxyCodeLine{33         \textcolor{keywordflow}{return} end -\/ start >= S;}
\DoxyCodeLine{34     \}}
\DoxyCodeLine{35     \textcolor{keywordtype}{size\_t} size()\textcolor{keyword}{ const }\{}
\DoxyCodeLine{36         \textcolor{keywordflow}{return} end -\/ start;}
\DoxyCodeLine{37     \}}
\DoxyCodeLine{38     \textcolor{keywordtype}{size\_t} capacity()\textcolor{keyword}{ const }\{}
\DoxyCodeLine{39         \textcolor{keywordflow}{return} S -\/ size();}
\DoxyCodeLine{40     \}}
\DoxyCodeLine{45     T* endData() \{}
\DoxyCodeLine{46         \textcolor{keywordtype}{size\_t} i = end \% S;}
\DoxyCodeLine{47         \textcolor{keywordflow}{return} \&data[i];}
\DoxyCodeLine{48     \}}
\DoxyCodeLine{49     \textcolor{keywordtype}{void} endIncr(\textcolor{keywordtype}{size\_t} n) \{}
\DoxyCodeLine{50         \textcolor{keywordtype}{size\_t} i = end \% S;}
\DoxyCodeLine{51         \textcolor{keywordtype}{size\_t} e1 = i + n;}
\DoxyCodeLine{52         \textcolor{keywordtype}{size\_t} e2 = (e1 < S) ? e1 : S;}
\DoxyCodeLine{53         \textcolor{comment}{// Copy data forward}}
\DoxyCodeLine{54         std::memcpy(\&data[S + i], \&data[i], \textcolor{keyword}{sizeof}(T) * (e2 -\/ i));}
\DoxyCodeLine{55 }
\DoxyCodeLine{56         \textcolor{keywordflow}{if} (e1 > S) \{}
\DoxyCodeLine{57             \textcolor{comment}{// Copy data backward from the floatd block to the main block}}
\DoxyCodeLine{58             std::memcpy(data, \&data[S], \textcolor{keyword}{sizeof}(T) * (e1 -\/ S));}
\DoxyCodeLine{59         \}}
\DoxyCodeLine{60         end += n;}
\DoxyCodeLine{61     \}}
\DoxyCodeLine{65     \textcolor{keyword}{const} T* startData()\textcolor{keyword}{ const }\{}
\DoxyCodeLine{66         \textcolor{keywordtype}{size\_t} i = start \% S;}
\DoxyCodeLine{67         \textcolor{keywordflow}{return} \&data[i];}
\DoxyCodeLine{68     \}}
\DoxyCodeLine{69     \textcolor{keywordtype}{void} startIncr(\textcolor{keywordtype}{size\_t} n) \{}
\DoxyCodeLine{70         start += n;}
\DoxyCodeLine{71     \}}
\DoxyCodeLine{72 \};}

\end{DoxyCode}
